{
  
    
        "post0": {
            "title": "Title",
            "content": "import pandas as pd import altair as alt from ipywidgets import interact . df = pd.read_csv(&#39;https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2018/2018-11-13/malaria_deaths.csv&#39;) #df.head() . df.columns = [&#39;Country&#39;, &#39;Code&#39;,&#39;Year&#39;,&#39;Death_Rate&#39;] df[&#39;Year&#39;] = pd.to_datetime(df[&#39;Year&#39;], format=&#39;%Y&#39;) df.head() . Country Code Year Death_Rate . 0 Afghanistan | AFG | 1990-01-01 | 6.802930 | . 1 Afghanistan | AFG | 1991-01-01 | 6.973494 | . 2 Afghanistan | AFG | 1992-01-01 | 6.989882 | . 3 Afghanistan | AFG | 1993-01-01 | 7.088983 | . 4 Afghanistan | AFG | 1994-01-01 | 7.392472 | . data = df.copy() def make_altair_chart(country): #brush = alt.selection_interval(encodings=[&#39;x&#39;]) chart = alt.Chart(data[data[&#39;Country&#39;] == country]).mark_line().encode( x = alt.X(&#39;Year:T&#39;, timeUnit=&#39;year&#39;, axis = alt.Axis(title = &#39;Year&#39;) ,), y = alt.Y(&#39;Death_Rate:Q&#39;, axis = alt.Axis(title = &#39;Death Rate&#39;,), ), ).properties( title = f&#39;{country}&#39;.capitalize(), width = 500, height = 300, ) return chart . interact(make_altair_chart, country = sorted(df[&#39;Country&#39;].unique()), ); .",
            "url": "https://lucylin1997.github.io/fastpage_copy/2021/09/27/Assignment3_Yili-Lin.html",
            "relUrl": "/2021/09/27/Assignment3_Yili-Lin.html",
            "date": " • Sep 27, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Assignment 2",
            "content": "import numpy as np import pandas as pd from decimal import * import math import unittest from sympy import * . Find the first 10-digit prime in the decimal expansion of $17 pi$ . The first 5 digits in the decimal expansion of $ pi$ are 14159. The first 4-digit prime in the decimal expansion of $ pi$ are 4159. You are asked to find the first 10-digit prime in the decimal expansion of $17 pi$. . Task 1: Write a function to generate an arbitrary large expansion of a mathematical expression like $ pi$. . The 3rd party library sympy has a function called N(expr, &lt;args&gt;) that allows us to directly expand the expression to a certain precision. . &gt;&gt; N(pi, 5) 3.1416 . def generate_expansion(precision, expression): &quot;&quot;&quot; This function returns an expansion of a mathematical expression given the precision. &quot;&quot;&quot; return N(expression, precision) . &gt;&gt; a = generate_expansion(5, pi) &gt;&gt; a 3.1416 &gt;&gt; type(a) sympy.core.numbers.Float . Then we can run a unit test to test the generate_expansion function | . class TestNotebook(unittest.TestCase): def test_genexp(self): self.assertEqual(str(generate_expansion(10, pi)), &#39;3.141592654&#39;) unittest.main(argv=[&#39;&#39;], verbosity=2, exit=False) . test_genexp (__main__.TestFunc) ... ok test_genexp (__main__.TestNotebook) ... ok - Ran 2 tests in 0.002s OK . &lt;unittest.main.TestProgram at 0x23203530ca0&gt; . Task 2: Write a function to check if a number is a prime number . Based on the definition of prime number, we need to check whether the number can be divided by any number that is less than the square root of the certain number. | . def is_prime(num): &quot;&quot;&quot; The function returns whether a given number is prime or not &quot;&quot;&quot; if num &gt; 1: for i in range(2, int(math.sqrt(num))+1): if (num % i) == 0: return False #break return True . &gt;&gt; is_prime(40) False . Then we can run a unit test to test the is_prime function | . class TestNotebook(unittest.TestCase): def test_isprime(self): self.assertEqual(is_prime(29), True) # 29 is a prime number self.assertEqual(is_prime(30), False) # 30 is not a prime number unittest.main(argv=[&#39;&#39;], verbosity=2, exit=False) . test_genexp (__main__.TestFunc) ... ok test_isprime (__main__.TestNotebook) ... ok - Ran 2 tests in 0.005s OK . &lt;unittest.main.TestProgram at 0x2320352b910&gt; . Task 3: Slicing Window . def slicing_window (number_str, idx): &quot;&quot;&quot; The function returns the specified width from a long iterable, the inputs are the string format of a number and the start point of the number &quot;&quot;&quot; return int(number_str[idx: idx+10]) . The slicing_window works like below . &gt;&gt; slicing_window(&#39;12345678899443878169846&#39;,1) 2345678899 . Then we can run a unit test to test the slicing_window function | . class TestNotebook(unittest.TestCase): def test_slicingwindow(self): self.assertEqual(slicing_window(&#39;12345667788990&#39;,2), 3456677889) unittest.main(argv=[&#39;&#39;], verbosity=2, exit=False) . test_genexp (__main__.TestFunc) ... ok test_slicingwindow (__main__.TestNotebook) ... ok - Ran 2 tests in 0.003s OK . &lt;unittest.main.TestProgram at 0x23203542760&gt; . def find_prime(precision, expression): &quot;&quot;&quot;The function returns the first 10-digit number in the expansion of the expression &quot;&quot;&quot; expansion = generate_expansion(precision, expression) formula = str(expansion) # The output of the generate_expansion is float, we need to convert it to string first string = formula.replace(&quot;.&quot;, &quot;&quot;) # replace the decimal point in the expansion #initial = False for idx in range(len(string)): if is_prime(slicing_window(string, idx)) is True: print( f&#39;The first 10-digit prime of {expression} is {slicing_window(string, idx)} and the start point is at {idx}&#39;) return slicing_window(string, idx) break . Then we can run a unit test to test the find_prime function | . class TestNotebook(unittest.TestCase): def test_slicingwindow(self): self.assertEqual(find_prime(500, exp(1)), 7427466391) unittest.main(argv=[&#39;&#39;], verbosity=2, exit=False) . test_genexp (__main__.TestFunc) ... ok test_slicingwindow (__main__.TestNotebook) ... . The first 10-digit prime of E is 7427466391 and the start point is at 99 . ok - Ran 2 tests in 0.015s OK . &lt;unittest.main.TestProgram at 0x23203542b20&gt; . The the final solution to the problem is: | . find_prime(500, 17*pi) . The first 10-digit prime of 17*pi is 8649375157 and the start point is at 20 . 8649375157 .",
            "url": "https://lucylin1997.github.io/fastpage_copy/jupyter/2021/09/17/Assignment2_Yili-Lin.html",
            "relUrl": "/jupyter/2021/09/17/Assignment2_Yili-Lin.html",
            "date": " • Sep 17, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Assignment 1",
            "content": "Question 1 Problem 15 Lattice Path . Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner. . . How many such routes are there through a 20×20 grid? . Solution to Question 1 . We can first consider the grid as a matrix, each element in the matrix represents the number of routes to that a location in the grid. For example, for a 2×2 grid, the corresponding matrix ${a_{i,j}}$ looks like this: $$ left( begin{array}{l} 0&amp; 1 &amp; 1 1&amp; 2&amp;3 1&amp; 3 &amp;6 end{array} right) $$ $a_{2,2}=6$, meaning that there are 6 routes to the bottom right corner. From the $2 times 2$ grid example and our observation, we find that there is always only one route for those located on the left and top of the grid. And for the remaining locations, the number of routes depend on those located on its top and left. So it is a dynamic programming problem. . import numpy as np def count_path(n): &quot;&quot;&quot;The parameter of the function is the dimension of the grid and it will return the number of routes to the bottom right corner of the grid &quot;&quot;&quot; # Dynamic Programming # Initilize the condition boundary mat = np.zeros((n+1, n+1)) for idx in range(len(mat)): mat[0][idx] = 1 # The top boundary of the grid only has one routes mat[idx][0] = 1 # The left boundary of the grid has only one routes for row in range(1, len(mat)): #dynamic programming for col in range(1, len(mat)): mat[row, col] = mat[row, col-1] + mat[row-1, col] return mat[n][n] #return the location on the bottom right corner if __name__ == &#39;__main__&#39;: print(count_path(20)) . 137846528820.0 . Question 2 Problem 50 Distinct Prime Factors . The prime 41, can be written as the sum of six consecutive primes: 41 = 2 + 3 + 5 + 7 + 11 + 13 This is the longest sum of consecutive primes that adds to a prime below one-hundred. . The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953. . Which prime, below one-million, can be written as the sum of the most consecutive primes? . Solution to Question 2 . First, we need to generate a list of prime number. There is a traditional algorithm called sieve of eratosthenes, which is designed for generating prime numbers less than a given value. . Sieve of Eratosthenes . Create a list of n-1 consecutive integers 2, 3, 4,..., n. 2 is the smallest prime number | For the first loop, set k to 2 | Let k increase k every step until it reaches n, that is, the algorithm loop over k, 2k, 3k,.. and mark these numbers in the list | Then find the smallest number in the list that is not marked and if no such number exists, the algorithm will stop. Otherwise, set k to the new number and iterate again. | At the end of the algorithm, all the numbers that are not marked are the prime numbers.Example:Find prime less than 20 &gt; List all the number that is less than 20 . 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 . Start with 2, we will mark 2, 4, 6,.. 20 . 2, 3, 5, 7, 9, 11, 13, 15, 17, 19 . The next start number is 3, we will mark 9,15 . 2, 3, 5, 7, 11, 13, 17, 19 . Then we can see that all the prime numbers less than 20 are listed in the above. . | With the sieve of eratosthenes algorithm, we can find all the prime numbers that are less than the given limit. When the limit is 100, the prime list is [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]. For the first loop, We start with the first prime number 2, and we will loop over the whole prime list to check if 2, 2 + 3, 2 + 3 + 5... is a prime number and if the summation exceeds 100. When the summation is a prime number, the current length of the consective prime numbers is the difference between the index of the first number and the last number, and if the summation exceeds 100, the stop index is the index of the last number. In this case, 2 + 3 + 5 + 7+ 11 + 13 + 17 + 19 + 23 = 100, so the stop index should be 9. Since 2 + 3 + 5 + 7+ 11 + 13= 41 is the longest sum of consecutive prime for the first loop, the length of consecutive after first loop is 6. Similarly we start with prime number 3, 5,.... until the algorithm stops. . import numpy as np import math def sieve_func(n): bool_list = [True] * n #This is the list used to indicate whether the number is marked, initially set all the elements to True bool_list[0] = False # 0 is not a prime number bool_list[1] = False # 1 is not a prime number for i in range(2, int(math.sqrt(n))+1): if bool_list[i] is True: for j in range(i**2, n, i): bool_list[j] = False prime_list = [index for index, boolvalue in enumerate(bool_list) if boolvalue == True] # find all the numbers that are not marked return prime_list . def find_distinct_factor(limit): &quot;&quot;&quot; The parameter of this function is the limit value, and the function will return the largest prime that can be written as the sum of the most consecutive primes under the given limit &quot;&quot;&quot; primes = sieve_func(limit) # Set the original length of the consecutive number to be 0 raw_length = 0 # initial value of the consecutive prime sum largest_sum = 0 # the last index for the end of the consecutive number, that is, if the index of the prime in the list exceeds this number, the summation will be larger than the given value # Initially set to the length of the prime list last_idx = len(primes) # two for loops for i in range(len(primes)): for j in range(i + raw_length, last_idx): summation = sum(primes[i:j]) if summation &lt; limit: if summation in primes: raw_length = j - i largest_sum = summation else: # When the summation of the consecutive number exceeds 100, we will set the stop point last_idx = j + 1 break return largest_sum . print(find_distinct_factor(1000000)) . 997651 . Question 3 Problem 123 Prime square remainders . Let $p_n$ be the nth prime: 2, 3, 5, 7, 11,... and let r be the reminder when $(p_n-1)^n + (p_n+1)^n$ is divided by $p_n^2$. . For example, when n = 3, $p_3 =5$, and $4^3 + 6^3 = 280 = 5 mod 25$. . The least value of n for which the reminder first exceeds $10^9$ is 7037. . Find the least value of n for which the reminder first exceeds $10^{10}$. . Solution to Question 3 . The expansion of $(p_n-1)^n$: . $(p_n-1)^n = p_n^n - (n-1)p_n^{n-1}+ binom{n}{n-2}p_n^{n-2}+...+(-1)^{n-1}np_n+(-1)^n$. . The expansion of $(p_n+1)^n$ is: . $(p_n+1)^n= p_n^n+ (n-1)p_n^{n-1}+ binom{n}{n-2}p_n^{n-2}+...+np_n+ 1$. . From the equation above we know that except for the last two terms, all the other terms are divisable by $p_n^2$. Thus, the reminder when $(p_n-1)^n+(p_n+1)^n$ is divided by $p_n^2$ should be: . $r = (-1)^{n-1}np_n+(-1)^n +np_n+1$. . So when n is an odd value, $r = 2np_n$, when n is an even number, $r= 2$. The question requires us to find the least value of n for which the reminder first exceeds $10^{10}$, so n must be an odd number. As is mentioned in the problem description: &quot;the least value of n for which the remainder first exceeds $10^9$ is 7037&quot;, thus the start point can begin with 7037 and we only care about the odd number. We can use the sieve function we defined in Question 2 and list all the prime number which is less than 5000000 (This number does not need to be exact 5000000, we just need to define a large number to make sure that there are enough prime numbers). Then we can loop over the prime number and find the least value of n when the reminder exceeds $10^{10}$ . def find_reminder(n): &quot;&quot;&quot; The find_reminder() function has one parameter n, which is the limit. The function will return the least value of n when the reminder exceeds the given limit. &quot;&quot;&quot; initial_n = 7037 #Set the initial value of n to 7037 limit = n #max limit for the reminder product = 0 primeslist = sieve_func(5_000_000) # Find all the prime number which is less than 5_000_000, the limit can vary while product &lt;= limit: initial_n += 2 product = 2 * initial_n * primeslist[initial_n-1] return initial_n if __name__ == &#39;__main__&#39;: print(find_reminder(10000000000)) . 21035 .",
            "url": "https://lucylin1997.github.io/fastpage_copy/jupyter/2021/09/01/Assignment1.html",
            "relUrl": "/jupyter/2021/09/01/Assignment1.html",
            "date": " • Sep 1, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Profile . Lucy Lin, a devoted and meticulous Master of Biostatistics candidate from Duke University with a solid background in mathematics and statistics, enthusiastic about the application of electronic health data in providing better health care to patients. Currently seeking an internship in Biostatistics/Data Science. Education . Duke University, School of Medicine . Master of Biostatistics &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; Aug,2020 - May, 2022 . Relevant courses: Introduction to Statistical Theory and Methods I and II, Applied Biostatistics Methods I and II, Introduction to Practice of Biostatistics I and II, Introduction to Statistical Programming I and II, Software Tools for Data Science. . Shanghai University of Finance and Economics . Information and Computing Science &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; Sep,2016 - Jun,2020 . Revelent courses: Data Structure, Big Data Process, Statistical Computing, Time series Analysis, Introduction of Stochastic Processes, Differential Equations. .",
          "url": "https://lucylin1997.github.io/fastpage_copy/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://lucylin1997.github.io/fastpage_copy/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}